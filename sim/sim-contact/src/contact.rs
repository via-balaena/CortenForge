//! Contact point and manifold types.
//!
//! These types represent the geometric information about contacts between bodies.
//! They are the output of narrow-phase collision detection and the input to
//! the contact force model.

use nalgebra::{Point3, Vector3};
use sim_types::BodyId;

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// A single contact point between two bodies.
///
/// Contact points are generated by narrow-phase collision detection and
/// contain the geometric information needed to compute contact forces.
///
/// # Conventions
///
/// - The `normal` vector points from body B toward body A
/// - `penetration` is positive when bodies overlap
/// - The contact `position` is typically on the surface of body A
#[derive(Debug, Clone, Copy, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ContactPoint {
    /// Position of the contact point in world coordinates.
    pub position: Point3<f64>,

    /// Contact normal in world coordinates, pointing from B toward A.
    ///
    /// This should be a unit vector. The normal force will act along this direction.
    pub normal: Vector3<f64>,

    /// Penetration depth in meters (positive when overlapping).
    ///
    /// This is the distance the bodies need to separate to break contact.
    /// Negative values indicate separation (no contact).
    pub penetration: f64,

    /// The first body in the contact pair.
    pub body_a: BodyId,

    /// The second body in the contact pair.
    pub body_b: BodyId,
}

impl ContactPoint {
    /// Create a new contact point.
    #[must_use]
    pub fn new(
        position: Point3<f64>,
        normal: Vector3<f64>,
        penetration: f64,
        body_a: BodyId,
        body_b: BodyId,
    ) -> Self {
        Self {
            position,
            normal: normal.normalize(),
            penetration,
            body_a,
            body_b,
        }
    }

    /// Create a contact point for a sphere resting on a plane.
    ///
    /// # Arguments
    ///
    /// * `sphere_center` - Center of the sphere in world coordinates
    /// * `sphere_radius` - Radius of the sphere
    /// * `plane_normal` - Normal of the plane (pointing away from solid)
    /// * `plane_distance` - Distance from origin to plane along normal
    /// * `body_sphere` - Body ID of the sphere
    /// * `body_plane` - Body ID of the plane
    #[must_use]
    pub fn sphere_plane(
        sphere_center: Point3<f64>,
        sphere_radius: f64,
        plane_normal: Vector3<f64>,
        plane_distance: f64,
        body_sphere: BodyId,
        body_plane: BodyId,
    ) -> Option<Self> {
        let normal = plane_normal.normalize();

        // Distance from sphere center to plane (positive = above plane)
        let center_distance = sphere_center.coords.dot(&normal) - plane_distance;

        // Penetration = radius - distance (positive when overlapping)
        let penetration = sphere_radius - center_distance;

        if penetration <= 0.0 {
            return None; // No contact
        }

        // Contact point is on the sphere surface, toward the plane
        let position =
            Point3::from(sphere_center.coords - normal * (sphere_radius - penetration * 0.5));

        Some(Self {
            position,
            normal, // Points from plane toward sphere
            penetration,
            body_a: body_sphere,
            body_b: body_plane,
        })
    }

    /// Create a contact point between two spheres.
    #[must_use]
    pub fn sphere_sphere(
        center_a: Point3<f64>,
        radius_a: f64,
        center_b: Point3<f64>,
        radius_b: f64,
        body_a: BodyId,
        body_b: BodyId,
    ) -> Option<Self> {
        let diff = center_a - center_b;
        let distance = diff.norm();

        if distance < 1e-10 {
            // Centers coincident - degenerate case
            return None;
        }

        let penetration = (radius_a + radius_b) - distance;

        if penetration <= 0.0 {
            return None; // No contact
        }

        let normal = diff / distance; // Points from B toward A

        // Contact point at midpoint of overlap region
        let contact_depth_a = radius_a - penetration * 0.5;
        let position = Point3::from(center_a.coords - normal * contact_depth_a);

        Some(Self {
            position,
            normal,
            penetration,
            body_a,
            body_b,
        })
    }

    /// Check if this contact is valid (bodies are overlapping).
    #[must_use]
    pub fn is_active(&self) -> bool {
        self.penetration > 0.0
    }

    /// Get the separation distance (negative of penetration).
    #[must_use]
    pub fn separation(&self) -> f64 {
        -self.penetration
    }

    /// Compute the relative velocity at the contact point.
    ///
    /// Returns v_A - v_B at the contact point, where positive normal component
    /// means bodies are separating.
    #[must_use]
    pub fn relative_velocity(
        &self,
        vel_a: &Vector3<f64>,
        omega_a: &Vector3<f64>,
        pos_a: &Point3<f64>,
        vel_b: &Vector3<f64>,
        omega_b: &Vector3<f64>,
        pos_b: &Point3<f64>,
    ) -> Vector3<f64> {
        // Velocity at contact point = v_com + omega × r
        let r_a = self.position - pos_a;
        let r_b = self.position - pos_b;

        let v_contact_a = vel_a + omega_a.cross(&r_a);
        let v_contact_b = vel_b + omega_b.cross(&r_b);

        v_contact_a - v_contact_b
    }

    /// Decompose relative velocity into normal and tangential components.
    ///
    /// Returns (v_normal, v_tangent) where v_normal is the component along
    /// the contact normal (positive = separating) and v_tangent is perpendicular.
    #[must_use]
    pub fn decompose_velocity(&self, relative_vel: &Vector3<f64>) -> (f64, Vector3<f64>) {
        let v_n = relative_vel.dot(&self.normal);
        let v_t = relative_vel - self.normal * v_n;
        (v_n, v_t)
    }

    /// Flip the contact direction (swap bodies A and B).
    #[must_use]
    pub fn flip(&self) -> Self {
        Self {
            position: self.position,
            normal: -self.normal,
            penetration: self.penetration,
            body_a: self.body_b,
            body_b: self.body_a,
        }
    }
}

/// A collection of contact points between two bodies.
///
/// Contact manifolds represent all active contacts between a pair of bodies.
/// For complex shapes, there may be multiple contact points (e.g., a box
/// resting on a plane has up to 4 contact points).
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ContactManifold {
    /// The contact points in this manifold.
    pub points: Vec<ContactPoint>,

    /// The first body in the contact pair.
    pub body_a: BodyId,

    /// The second body in the contact pair.
    pub body_b: BodyId,

    /// Cached average normal (for quick queries).
    average_normal: Vector3<f64>,
}

impl ContactManifold {
    /// Create a new contact manifold.
    #[must_use]
    pub fn new(body_a: BodyId, body_b: BodyId) -> Self {
        Self {
            points: Vec::new(),
            body_a,
            body_b,
            average_normal: Vector3::zeros(),
        }
    }

    /// Create a manifold from a single contact point.
    #[must_use]
    pub fn from_point(contact: ContactPoint) -> Self {
        Self {
            body_a: contact.body_a,
            body_b: contact.body_b,
            average_normal: contact.normal,
            points: vec![contact],
        }
    }

    /// Create a manifold from multiple contact points.
    ///
    /// All points should be between the same pair of bodies.
    #[must_use]
    pub fn from_points(points: Vec<ContactPoint>) -> Option<Self> {
        if points.is_empty() {
            return None;
        }

        let body_a = points[0].body_a;
        let body_b = points[0].body_b;

        // Verify all points are for the same body pair
        if !points
            .iter()
            .all(|p| p.body_a == body_a && p.body_b == body_b)
        {
            return None;
        }

        let average_normal = if points.len() == 1 {
            points[0].normal
        } else {
            let sum: Vector3<f64> = points.iter().map(|p| p.normal).sum();
            let norm = sum.norm();
            if norm < 1e-10 {
                points[0].normal
            } else {
                sum / norm
            }
        };

        Some(Self {
            points,
            body_a,
            body_b,
            average_normal,
        })
    }

    /// Add a contact point to the manifold.
    pub fn add_point(&mut self, point: ContactPoint) {
        self.points.push(point);
        self.update_average_normal();
    }

    /// Update the cached average normal.
    fn update_average_normal(&mut self) {
        if self.points.is_empty() {
            self.average_normal = Vector3::zeros();
            return;
        }

        let sum: Vector3<f64> = self.points.iter().map(|p| p.normal).sum();
        let norm = sum.norm();
        self.average_normal = if norm < 1e-10 {
            self.points[0].normal
        } else {
            sum / norm
        };
    }

    /// Get the average contact normal.
    #[must_use]
    pub fn average_normal(&self) -> Vector3<f64> {
        self.average_normal
    }

    /// Get the deepest penetration in the manifold.
    #[must_use]
    pub fn max_penetration(&self) -> f64 {
        self.points
            .iter()
            .map(|p| p.penetration)
            .fold(0.0, f64::max)
    }

    /// Get the centroid of all contact points.
    #[must_use]
    pub fn centroid(&self) -> Option<Point3<f64>> {
        if self.points.is_empty() {
            return None;
        }

        let sum: Vector3<f64> = self.points.iter().map(|p| p.position.coords).sum();
        Some(Point3::from(sum / self.points.len() as f64))
    }

    /// Check if the manifold has any active contacts.
    #[must_use]
    pub fn is_active(&self) -> bool {
        self.points.iter().any(|p| p.is_active())
    }

    /// Get the number of contact points.
    #[must_use]
    pub fn len(&self) -> usize {
        self.points.len()
    }

    /// Check if the manifold is empty.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.points.is_empty()
    }

    /// Iterate over contact points.
    pub fn iter(&self) -> impl Iterator<Item = &ContactPoint> {
        self.points.iter()
    }

    /// Remove contacts that are no longer active (separation > threshold).
    pub fn prune(&mut self, separation_threshold: f64) {
        self.points
            .retain(|p| p.penetration > -separation_threshold);
        self.update_average_normal();
    }

    /// Limit the manifold to at most N points, keeping the deepest.
    pub fn limit(&mut self, max_points: usize) {
        if self.points.len() <= max_points {
            return;
        }

        // Sort by penetration depth (deepest first)
        self.points.sort_by(|a, b| {
            b.penetration
                .partial_cmp(&a.penetration)
                .unwrap_or(std::cmp::Ordering::Equal)
        });

        self.points.truncate(max_points);
        self.update_average_normal();
    }
}

/// The force resulting from a contact.
///
/// Contact forces are decomposed into normal (perpendicular to surface)
/// and friction (tangential to surface) components.
#[derive(Debug, Clone, Copy, PartialEq, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ContactForce {
    /// Normal force vector (perpendicular to contact surface).
    ///
    /// Points from body B toward body A (same direction as contact normal).
    /// Magnitude is always non-negative (contacts can only push, not pull).
    pub normal: Vector3<f64>,

    /// Friction force vector (tangential to contact surface).
    ///
    /// Opposes relative sliding motion between the bodies.
    /// Magnitude is bounded by μ * |F_normal| (friction cone).
    pub friction: Vector3<f64>,

    /// The contact point this force applies to.
    pub position: Point3<f64>,
}

impl ContactForce {
    /// Create a zero contact force.
    #[must_use]
    pub fn zero() -> Self {
        Self::default()
    }

    /// Create a contact force with only normal component.
    #[must_use]
    pub fn normal_only(normal: Vector3<f64>, position: Point3<f64>) -> Self {
        Self {
            normal,
            friction: Vector3::zeros(),
            position,
        }
    }

    /// Create a contact force with both components.
    #[must_use]
    pub fn new(normal: Vector3<f64>, friction: Vector3<f64>, position: Point3<f64>) -> Self {
        Self {
            normal,
            friction,
            position,
        }
    }

    /// Get the total force (normal + friction).
    #[must_use]
    pub fn total(&self) -> Vector3<f64> {
        self.normal + self.friction
    }

    /// Get the magnitude of the normal force.
    #[must_use]
    pub fn normal_magnitude(&self) -> f64 {
        self.normal.norm()
    }

    /// Get the magnitude of the friction force.
    #[must_use]
    pub fn friction_magnitude(&self) -> f64 {
        self.friction.norm()
    }

    /// Compute the torque about a point (e.g., center of mass).
    #[must_use]
    pub fn torque_about(&self, point: &Point3<f64>) -> Vector3<f64> {
        let r = self.position - point;
        r.cross(&self.total())
    }

    /// Check if the force is effectively zero.
    #[must_use]
    pub fn is_zero(&self, epsilon: f64) -> bool {
        self.normal.norm_squared() < epsilon * epsilon
            && self.friction.norm_squared() < epsilon * epsilon
    }

    /// Scale the force by a factor.
    #[must_use]
    pub fn scale(&self, factor: f64) -> Self {
        Self {
            normal: self.normal * factor,
            friction: self.friction * factor,
            position: self.position,
        }
    }

    /// Add another contact force (assumes same position).
    #[must_use]
    pub fn add(&self, other: &Self) -> Self {
        Self {
            normal: self.normal + other.normal,
            friction: self.friction + other.friction,
            position: self.position, // Keep original position
        }
    }
}

#[cfg(test)]
#[allow(
    clippy::unwrap_used,
    clippy::expect_used,
    clippy::float_cmp,
    clippy::similar_names
)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;

    #[test]
    fn test_contact_point_sphere_plane() {
        // Sphere at height 0.9 with radius 1.0, plane at z=0
        let contact = ContactPoint::sphere_plane(
            Point3::new(0.0, 0.0, 0.9),
            1.0,
            Vector3::new(0.0, 0.0, 1.0),
            0.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        assert_relative_eq!(contact.penetration, 0.1, epsilon = 1e-10);
        assert_relative_eq!(contact.normal.z, 1.0, epsilon = 1e-10);
    }

    #[test]
    fn test_contact_point_sphere_plane_no_contact() {
        // Sphere at height 2.0 with radius 1.0, plane at z=0
        let contact = ContactPoint::sphere_plane(
            Point3::new(0.0, 0.0, 2.0),
            1.0,
            Vector3::new(0.0, 0.0, 1.0),
            0.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        assert!(contact.is_none());
    }

    #[test]
    fn test_contact_point_sphere_sphere() {
        // Two spheres with radius 1.0, centers 1.5 apart
        let contact = ContactPoint::sphere_sphere(
            Point3::new(0.0, 0.0, 0.0),
            1.0,
            Point3::new(1.5, 0.0, 0.0),
            1.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        assert_relative_eq!(contact.penetration, 0.5, epsilon = 1e-10);
        assert_relative_eq!(contact.normal.x, -1.0, epsilon = 1e-10);
    }

    #[test]
    fn test_velocity_decomposition() {
        let contact = ContactPoint {
            position: Point3::origin(),
            normal: Vector3::new(0.0, 0.0, 1.0),
            penetration: 0.01,
            body_a: BodyId::new(0),
            body_b: BodyId::new(1),
        };

        let velocity = Vector3::new(1.0, 2.0, 3.0);
        let (v_n, v_t) = contact.decompose_velocity(&velocity);

        assert_relative_eq!(v_n, 3.0, epsilon = 1e-10);
        assert_relative_eq!(v_t.x, 1.0, epsilon = 1e-10);
        assert_relative_eq!(v_t.y, 2.0, epsilon = 1e-10);
        assert_relative_eq!(v_t.z, 0.0, epsilon = 1e-10);
    }

    #[test]
    fn test_contact_manifold() {
        let p1 = ContactPoint {
            position: Point3::new(-1.0, 0.0, 0.0),
            normal: Vector3::new(0.0, 0.0, 1.0),
            penetration: 0.01,
            body_a: BodyId::new(0),
            body_b: BodyId::new(1),
        };

        let p2 = ContactPoint {
            position: Point3::new(1.0, 0.0, 0.0),
            normal: Vector3::new(0.0, 0.0, 1.0),
            penetration: 0.02,
            body_a: BodyId::new(0),
            body_b: BodyId::new(1),
        };

        let manifold = ContactManifold::from_points(vec![p1, p2]).unwrap();

        assert_eq!(manifold.len(), 2);
        assert_relative_eq!(manifold.max_penetration(), 0.02, epsilon = 1e-10);

        let centroid = manifold.centroid().unwrap();
        assert_relative_eq!(centroid.x, 0.0, epsilon = 1e-10);
    }

    #[test]
    fn test_contact_force_torque() {
        let force = ContactForce {
            normal: Vector3::new(0.0, 0.0, 100.0),
            friction: Vector3::new(-10.0, 0.0, 0.0),
            position: Point3::new(1.0, 0.0, 0.0),
        };

        // Torque about origin: r × F = (1,0,0) × (-10, 0, 100)
        let torque = force.torque_about(&Point3::origin());

        // (1,0,0) × (-10,0,100) = (0*100 - 0*0, 0*(-10) - 1*100, 1*0 - 0*(-10))
        //                       = (0, -100, 0)
        assert_relative_eq!(torque.y, -100.0, epsilon = 1e-10);
    }
}
