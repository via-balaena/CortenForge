//! Contact point and manifold types.
//!
//! These types represent the geometric information about contacts between bodies.
//! They are the output of narrow-phase collision detection and the input to
//! the contact force model.

use nalgebra::{Point3, Vector3};
use sim_types::BodyId;

#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// Safely normalize a vector, returning a default if the vector is too short.
/// This prevents NaN from dividing by near-zero values.
fn safe_normalize(v: Vector3<f64>, default: Vector3<f64>) -> Vector3<f64> {
    let norm = v.norm();
    if norm > 1e-10 { v / norm } else { default }
}

/// A single contact point between two bodies.
///
/// Contact points are generated by narrow-phase collision detection and
/// contain the geometric information needed to compute contact forces.
///
/// # Conventions
///
/// - The `normal` vector points from body B toward body A
/// - `penetration` is positive when bodies overlap
/// - The contact `position` is typically on the surface of body A
#[derive(Debug, Clone, Copy, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ContactPoint {
    /// Position of the contact point in world coordinates.
    pub position: Point3<f64>,

    /// Contact normal in world coordinates, pointing from B toward A.
    ///
    /// This should be a unit vector. The normal force will act along this direction.
    pub normal: Vector3<f64>,

    /// Penetration depth in meters (positive when overlapping).
    ///
    /// This is the distance the bodies need to separate to break contact.
    /// Negative values indicate separation (no contact).
    pub penetration: f64,

    /// The first body in the contact pair.
    pub body_a: BodyId,

    /// The second body in the contact pair.
    pub body_b: BodyId,
}

impl ContactPoint {
    /// Create a new contact point.
    #[must_use]
    pub fn new(
        position: Point3<f64>,
        normal: Vector3<f64>,
        penetration: f64,
        body_a: BodyId,
        body_b: BodyId,
    ) -> Self {
        Self {
            position,
            // Safe normalize - default to Z-up if normal is zero-length
            normal: safe_normalize(normal, Vector3::z()),
            penetration,
            body_a,
            body_b,
        }
    }

    /// Create a contact point for a sphere resting on a plane.
    ///
    /// # Arguments
    ///
    /// * `sphere_center` - Center of the sphere in world coordinates
    /// * `sphere_radius` - Radius of the sphere
    /// * `plane_normal` - Normal of the plane (pointing away from solid)
    /// * `plane_distance` - Distance from origin to plane along normal
    /// * `body_sphere` - Body ID of the sphere
    /// * `body_plane` - Body ID of the plane
    #[must_use]
    pub fn sphere_plane(
        sphere_center: Point3<f64>,
        sphere_radius: f64,
        plane_normal: Vector3<f64>,
        plane_distance: f64,
        body_sphere: BodyId,
        body_plane: BodyId,
    ) -> Option<Self> {
        // Safe normalize - return None if plane normal is degenerate
        let norm = plane_normal.norm();
        if norm < 1e-10 {
            return None;
        }
        let normal = plane_normal / norm;

        // Distance from sphere center to plane (positive = above plane)
        let center_distance = sphere_center.coords.dot(&normal) - plane_distance;

        // Penetration = radius - distance (positive when overlapping)
        let penetration = sphere_radius - center_distance;

        if penetration <= 0.0 {
            return None; // No contact
        }

        // Contact point is on the sphere surface, toward the plane
        let position =
            Point3::from(sphere_center.coords - normal * (sphere_radius - penetration * 0.5));

        Some(Self {
            position,
            normal, // Points from plane toward sphere
            penetration,
            body_a: body_sphere,
            body_b: body_plane,
        })
    }

    /// Create a contact point between two spheres.
    #[must_use]
    pub fn sphere_sphere(
        center_a: Point3<f64>,
        radius_a: f64,
        center_b: Point3<f64>,
        radius_b: f64,
        body_a: BodyId,
        body_b: BodyId,
    ) -> Option<Self> {
        let diff = center_a - center_b;
        let distance = diff.norm();

        if distance < 1e-10 {
            // Centers coincident - degenerate case
            return None;
        }

        let penetration = (radius_a + radius_b) - distance;

        if penetration <= 0.0 {
            return None; // No contact
        }

        let normal = diff / distance; // Points from B toward A

        // Contact point at midpoint of overlap region
        let contact_depth_a = radius_a - penetration * 0.5;
        let position = Point3::from(center_a.coords - normal * contact_depth_a);

        Some(Self {
            position,
            normal,
            penetration,
            body_a,
            body_b,
        })
    }

    /// Create a contact point between a box and a sphere.
    ///
    /// The box is axis-aligned at the given center position.
    ///
    /// # Arguments
    ///
    /// * `box_center` - Center of the box in world coordinates
    /// * `box_half_extents` - Half-extents of the box in each axis
    /// * `sphere_center` - Center of the sphere in world coordinates
    /// * `sphere_radius` - Radius of the sphere
    /// * `body_box` - Body ID of the box
    /// * `body_sphere` - Body ID of the sphere
    #[must_use]
    pub fn box_sphere(
        box_center: Point3<f64>,
        box_half_extents: Vector3<f64>,
        sphere_center: Point3<f64>,
        sphere_radius: f64,
        body_box: BodyId,
        body_sphere: BodyId,
    ) -> Option<Self> {
        // Find the closest point on the box to the sphere center
        let relative = sphere_center - box_center;

        // Clamp to box bounds
        let closest = Vector3::new(
            relative.x.clamp(-box_half_extents.x, box_half_extents.x),
            relative.y.clamp(-box_half_extents.y, box_half_extents.y),
            relative.z.clamp(-box_half_extents.z, box_half_extents.z),
        );

        let closest_point = box_center + closest;
        let diff = sphere_center - closest_point;
        let distance = diff.norm();

        // Check if sphere center is inside the box
        let inside = relative.x.abs() <= box_half_extents.x
            && relative.y.abs() <= box_half_extents.y
            && relative.z.abs() <= box_half_extents.z;

        if inside {
            // Sphere center is inside the box - find the closest face
            let distances_to_faces = [
                (
                    box_half_extents.x - relative.x.abs(),
                    0,
                    relative.x.signum(),
                ),
                (
                    box_half_extents.y - relative.y.abs(),
                    1,
                    relative.y.signum(),
                ),
                (
                    box_half_extents.z - relative.z.abs(),
                    2,
                    relative.z.signum(),
                ),
            ];

            // Find minimum distance to a face
            let (min_dist, axis, sign) = distances_to_faces
                .iter()
                .min_by(|a, b| a.0.partial_cmp(&b.0).unwrap_or(std::cmp::Ordering::Equal))
                .copied()
                .unwrap_or((0.0, 2, 1.0));

            let penetration = min_dist + sphere_radius;

            // Normal points from box toward sphere (outward from the closest face)
            let mut normal = Vector3::zeros();
            normal[axis] = if sign == 0.0 { 1.0 } else { sign };

            // Contact point on the box surface
            let mut contact_on_box = relative;
            contact_on_box[axis] = box_half_extents[axis] * normal[axis];
            let position = box_center + contact_on_box;

            Some(Self {
                position,
                normal,
                penetration,
                body_a: body_box,
                body_b: body_sphere,
            })
        } else if distance < sphere_radius {
            // Sphere overlaps the box from outside
            // Guard against degenerate case where sphere center is exactly on box surface
            if distance < 1e-10 {
                return None;
            }
            let penetration = sphere_radius - distance;
            let normal = diff / distance; // Points from box toward sphere

            // Contact point at midpoint of overlap
            let position = closest_point + normal * (penetration * 0.5);

            Some(Self {
                position,
                normal,
                penetration,
                body_a: body_box,
                body_b: body_sphere,
            })
        } else {
            None // No contact
        }
    }

    /// Create a contact point between a box and a plane.
    ///
    /// The box is axis-aligned at the given center position.
    /// Returns the deepest penetrating corner as a single contact point.
    ///
    /// # Arguments
    ///
    /// * `box_center` - Center of the box in world coordinates
    /// * `box_half_extents` - Half-extents of the box in each axis
    /// * `plane_normal` - Normal of the plane (pointing away from solid)
    /// * `plane_distance` - Distance from origin to plane along normal
    /// * `body_box` - Body ID of the box
    /// * `body_plane` - Body ID of the plane
    #[must_use]
    pub fn box_plane(
        box_center: Point3<f64>,
        box_half_extents: Vector3<f64>,
        plane_normal: Vector3<f64>,
        plane_distance: f64,
        body_box: BodyId,
        body_plane: BodyId,
    ) -> Option<Self> {
        // Safe normalize - return None if plane normal is degenerate
        let norm = plane_normal.norm();
        if norm < 1e-10 {
            return None;
        }
        let normal = plane_normal / norm;

        // Find the corner of the box that is deepest into the plane
        // This is the corner that is most opposite to the plane normal
        let corner_offset = Vector3::new(
            if normal.x >= 0.0 {
                -box_half_extents.x
            } else {
                box_half_extents.x
            },
            if normal.y >= 0.0 {
                -box_half_extents.y
            } else {
                box_half_extents.y
            },
            if normal.z >= 0.0 {
                -box_half_extents.z
            } else {
                box_half_extents.z
            },
        );

        let deepest_corner = box_center + corner_offset;
        let corner_distance = deepest_corner.coords.dot(&normal) - plane_distance;

        if corner_distance >= 0.0 {
            return None; // No contact
        }

        let penetration = -corner_distance;
        let position = deepest_corner + normal * (penetration * 0.5);

        Some(Self {
            position,
            normal,
            penetration,
            body_a: body_box,
            body_b: body_plane,
        })
    }

    /// Create contact points between a box and a plane (manifold version).
    ///
    /// Returns all corners that are penetrating the plane.
    #[must_use]
    pub fn box_plane_manifold(
        box_center: Point3<f64>,
        box_half_extents: Vector3<f64>,
        plane_normal: Vector3<f64>,
        plane_distance: f64,
        body_box: BodyId,
        body_plane: BodyId,
    ) -> Vec<Self> {
        // Safe normalize - return empty if plane normal is degenerate
        let norm = plane_normal.norm();
        if norm < 1e-10 {
            return Vec::new();
        }
        let normal = plane_normal / norm;
        let mut contacts = Vec::new();

        // Check all 8 corners
        for &sx in &[-1.0, 1.0] {
            for &sy in &[-1.0, 1.0] {
                for &sz in &[-1.0, 1.0] {
                    let corner = box_center
                        + Vector3::new(
                            sx * box_half_extents.x,
                            sy * box_half_extents.y,
                            sz * box_half_extents.z,
                        );

                    let corner_distance = corner.coords.dot(&normal) - plane_distance;

                    if corner_distance < 0.0 {
                        let penetration = -corner_distance;
                        let position = corner + normal * (penetration * 0.5);

                        contacts.push(Self {
                            position,
                            normal,
                            penetration,
                            body_a: body_box,
                            body_b: body_plane,
                        });
                    }
                }
            }
        }

        contacts
    }

    /// Create a contact point between two axis-aligned boxes.
    ///
    /// Uses the Separating Axis Theorem (SAT) to detect overlap and
    /// compute the minimum penetration axis.
    ///
    /// # Arguments
    ///
    /// * `center_a` - Center of box A in world coordinates
    /// * `half_extents_a` - Half-extents of box A
    /// * `center_b` - Center of box B in world coordinates
    /// * `half_extents_b` - Half-extents of box B
    /// * `body_a` - Body ID of box A
    /// * `body_b` - Body ID of box B
    #[must_use]
    pub fn box_box(
        center_a: Point3<f64>,
        half_extents_a: Vector3<f64>,
        center_b: Point3<f64>,
        half_extents_b: Vector3<f64>,
        body_a: BodyId,
        body_b: BodyId,
    ) -> Option<Self> {
        let diff = center_b - center_a;

        // Check overlap on each axis and find minimum penetration
        let overlap_x = (half_extents_a.x + half_extents_b.x) - diff.x.abs();
        let overlap_y = (half_extents_a.y + half_extents_b.y) - diff.y.abs();
        let overlap_z = (half_extents_a.z + half_extents_b.z) - diff.z.abs();

        // If any overlap is negative, boxes are separated
        if overlap_x <= 0.0 || overlap_y <= 0.0 || overlap_z <= 0.0 {
            return None;
        }

        // Find the axis with minimum penetration (separating axis)
        let (penetration, axis_idx) = if overlap_x <= overlap_y && overlap_x <= overlap_z {
            (overlap_x, 0)
        } else if overlap_y <= overlap_z {
            (overlap_y, 1)
        } else {
            (overlap_z, 2)
        };

        // Normal points from B toward A
        let mut normal = Vector3::zeros();
        normal[axis_idx] = if diff[axis_idx] >= 0.0 { -1.0 } else { 1.0 };

        // Contact point at the center of the overlap region
        let contact_center = Point3::from((center_a.coords + center_b.coords) * 0.5);

        // Adjust contact point to be on the surface of box A
        let mut position = contact_center;
        position[axis_idx] = center_a[axis_idx] + normal[axis_idx] * half_extents_a[axis_idx];

        Some(Self {
            position,
            normal,
            penetration,
            body_a,
            body_b,
        })
    }

    /// Create a contact point between a capsule and a plane.
    ///
    /// A capsule is defined by two endpoints and a radius.
    ///
    /// # Arguments
    ///
    /// * `capsule_start` - Start point of the capsule axis
    /// * `capsule_end` - End point of the capsule axis
    /// * `capsule_radius` - Radius of the capsule
    /// * `plane_normal` - Normal of the plane
    /// * `plane_distance` - Distance from origin to plane
    /// * `body_capsule` - Body ID of the capsule
    /// * `body_plane` - Body ID of the plane
    #[must_use]
    pub fn capsule_plane(
        capsule_start: Point3<f64>,
        capsule_end: Point3<f64>,
        capsule_radius: f64,
        plane_normal: Vector3<f64>,
        plane_distance: f64,
        body_capsule: BodyId,
        body_plane: BodyId,
    ) -> Option<Self> {
        // Safe normalize - return None if plane normal is degenerate
        let norm = plane_normal.norm();
        if norm < 1e-10 {
            return None;
        }
        let normal = plane_normal / norm;

        // Find the point on the capsule axis closest to the plane
        let start_dist = capsule_start.coords.dot(&normal) - plane_distance;
        let end_dist = capsule_end.coords.dot(&normal) - plane_distance;

        // Use the endpoint that's closer to (or deeper into) the plane
        let (closest_point, min_dist) = if start_dist < end_dist {
            (capsule_start, start_dist)
        } else {
            (capsule_end, end_dist)
        };

        let penetration = capsule_radius - min_dist;

        if penetration <= 0.0 {
            return None;
        }

        // Contact point on capsule surface
        let position = closest_point - normal * (capsule_radius - penetration * 0.5);

        Some(Self {
            position,
            normal,
            penetration,
            body_a: body_capsule,
            body_b: body_plane,
        })
    }

    /// Create a contact point between a capsule and a sphere.
    ///
    /// # Arguments
    ///
    /// * `capsule_start` - Start point of the capsule axis
    /// * `capsule_end` - End point of the capsule axis
    /// * `capsule_radius` - Radius of the capsule
    /// * `sphere_center` - Center of the sphere
    /// * `sphere_radius` - Radius of the sphere
    /// * `body_capsule` - Body ID of the capsule
    /// * `body_sphere` - Body ID of the sphere
    #[must_use]
    pub fn capsule_sphere(
        capsule_start: Point3<f64>,
        capsule_end: Point3<f64>,
        capsule_radius: f64,
        sphere_center: Point3<f64>,
        sphere_radius: f64,
        body_capsule: BodyId,
        body_sphere: BodyId,
    ) -> Option<Self> {
        // Find closest point on capsule axis to sphere center
        let axis = capsule_end - capsule_start;
        let axis_len_sq = axis.norm_squared();

        let closest_on_axis = if axis_len_sq < 1e-10 {
            // Degenerate capsule (a sphere)
            capsule_start
        } else {
            let t = ((sphere_center - capsule_start).dot(&axis) / axis_len_sq).clamp(0.0, 1.0);
            capsule_start + axis * t
        };

        // Now it's a sphere-sphere test
        let diff = sphere_center - closest_on_axis;
        let distance = diff.norm();

        if distance < 1e-10 {
            return None; // Degenerate case
        }

        let combined_radius = capsule_radius + sphere_radius;
        let penetration = combined_radius - distance;

        if penetration <= 0.0 {
            return None;
        }

        let normal = diff / distance; // Points from capsule toward sphere

        // Contact point at midpoint of overlap
        let position = closest_on_axis + normal * (capsule_radius - penetration * 0.5);

        Some(Self {
            position,
            normal,
            penetration,
            body_a: body_capsule,
            body_b: body_sphere,
        })
    }

    /// Create a contact point between two capsules.
    ///
    /// # Arguments
    ///
    /// * `start_a`, `end_a` - Axis endpoints of capsule A
    /// * `radius_a` - Radius of capsule A
    /// * `start_b`, `end_b` - Axis endpoints of capsule B
    /// * `radius_b` - Radius of capsule B
    /// * `body_a` - Body ID of capsule A
    /// * `body_b` - Body ID of capsule B
    #[must_use]
    #[allow(clippy::too_many_arguments)]
    pub fn capsule_capsule(
        start_a: Point3<f64>,
        end_a: Point3<f64>,
        radius_a: f64,
        start_b: Point3<f64>,
        end_b: Point3<f64>,
        radius_b: f64,
        body_a: BodyId,
        body_b: BodyId,
    ) -> Option<Self> {
        // Find closest points between two line segments
        let (closest_a, closest_b) = closest_points_segments(start_a, end_a, start_b, end_b);

        // Now it's a sphere-sphere test between the closest points
        let diff = closest_a - closest_b;
        let distance = diff.norm();

        if distance < 1e-10 {
            return None; // Degenerate case
        }

        let combined_radius = radius_a + radius_b;
        let penetration = combined_radius - distance;

        if penetration <= 0.0 {
            return None;
        }

        let normal = diff / distance; // Points from B toward A

        // Contact point at midpoint
        let position = closest_b + normal * (radius_b + penetration * 0.5);

        Some(Self {
            position,
            normal,
            penetration,
            body_a,
            body_b,
        })
    }

    /// Check if this contact is valid (bodies are overlapping).
    #[must_use]
    pub fn is_active(&self) -> bool {
        self.penetration > 0.0
    }

    /// Get the separation distance (negative of penetration).
    #[must_use]
    pub fn separation(&self) -> f64 {
        -self.penetration
    }

    /// Compute the relative velocity at the contact point.
    ///
    /// Returns v_A - v_B at the contact point, where positive normal component
    /// means bodies are separating.
    #[must_use]
    pub fn relative_velocity(
        &self,
        vel_a: &Vector3<f64>,
        omega_a: &Vector3<f64>,
        pos_a: &Point3<f64>,
        vel_b: &Vector3<f64>,
        omega_b: &Vector3<f64>,
        pos_b: &Point3<f64>,
    ) -> Vector3<f64> {
        // Velocity at contact point = v_com + omega × r
        let r_a = self.position - pos_a;
        let r_b = self.position - pos_b;

        let v_contact_a = vel_a + omega_a.cross(&r_a);
        let v_contact_b = vel_b + omega_b.cross(&r_b);

        v_contact_a - v_contact_b
    }

    /// Decompose relative velocity into normal and tangential components.
    ///
    /// Returns (v_normal, v_tangent) where v_normal is the component along
    /// the contact normal (positive = separating) and v_tangent is perpendicular.
    #[must_use]
    pub fn decompose_velocity(&self, relative_vel: &Vector3<f64>) -> (f64, Vector3<f64>) {
        let v_n = relative_vel.dot(&self.normal);
        let v_t = relative_vel - self.normal * v_n;
        (v_n, v_t)
    }

    /// Flip the contact direction (swap bodies A and B).
    #[must_use]
    pub fn flip(&self) -> Self {
        Self {
            position: self.position,
            normal: -self.normal,
            penetration: self.penetration,
            body_a: self.body_b,
            body_b: self.body_a,
        }
    }
}

/// A collection of contact points between two bodies.
///
/// Contact manifolds represent all active contacts between a pair of bodies.
/// For complex shapes, there may be multiple contact points (e.g., a box
/// resting on a plane has up to 4 contact points).
#[derive(Debug, Clone, PartialEq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ContactManifold {
    /// The contact points in this manifold.
    pub points: Vec<ContactPoint>,

    /// The first body in the contact pair.
    pub body_a: BodyId,

    /// The second body in the contact pair.
    pub body_b: BodyId,

    /// Cached average normal (for quick queries).
    average_normal: Vector3<f64>,
}

impl ContactManifold {
    /// Create a new contact manifold.
    #[must_use]
    pub fn new(body_a: BodyId, body_b: BodyId) -> Self {
        Self {
            points: Vec::new(),
            body_a,
            body_b,
            average_normal: Vector3::zeros(),
        }
    }

    /// Create a manifold from a single contact point.
    #[must_use]
    pub fn from_point(contact: ContactPoint) -> Self {
        Self {
            body_a: contact.body_a,
            body_b: contact.body_b,
            average_normal: contact.normal,
            points: vec![contact],
        }
    }

    /// Create a manifold from multiple contact points.
    ///
    /// All points should be between the same pair of bodies.
    #[must_use]
    pub fn from_points(points: Vec<ContactPoint>) -> Option<Self> {
        if points.is_empty() {
            return None;
        }

        let body_a = points[0].body_a;
        let body_b = points[0].body_b;

        // Verify all points are for the same body pair
        if !points
            .iter()
            .all(|p| p.body_a == body_a && p.body_b == body_b)
        {
            return None;
        }

        let average_normal = if points.len() == 1 {
            points[0].normal
        } else {
            let sum: Vector3<f64> = points.iter().map(|p| p.normal).sum();
            let norm = sum.norm();
            if norm < 1e-10 {
                points[0].normal
            } else {
                sum / norm
            }
        };

        Some(Self {
            points,
            body_a,
            body_b,
            average_normal,
        })
    }

    /// Add a contact point to the manifold.
    pub fn add_point(&mut self, point: ContactPoint) {
        self.points.push(point);
        self.update_average_normal();
    }

    /// Update the cached average normal.
    fn update_average_normal(&mut self) {
        if self.points.is_empty() {
            self.average_normal = Vector3::zeros();
            return;
        }

        let sum: Vector3<f64> = self.points.iter().map(|p| p.normal).sum();
        let norm = sum.norm();
        self.average_normal = if norm < 1e-10 {
            self.points[0].normal
        } else {
            sum / norm
        };
    }

    /// Get the average contact normal.
    #[must_use]
    pub fn average_normal(&self) -> Vector3<f64> {
        self.average_normal
    }

    /// Get the deepest penetration in the manifold.
    #[must_use]
    pub fn max_penetration(&self) -> f64 {
        self.points
            .iter()
            .map(|p| p.penetration)
            .fold(0.0, f64::max)
    }

    /// Get the centroid of all contact points.
    #[must_use]
    pub fn centroid(&self) -> Option<Point3<f64>> {
        if self.points.is_empty() {
            return None;
        }

        let sum: Vector3<f64> = self.points.iter().map(|p| p.position.coords).sum();
        #[allow(clippy::cast_precision_loss)] // manifold point count is always small
        let count = self.points.len() as f64;
        Some(Point3::from(sum / count))
    }

    /// Check if the manifold has any active contacts.
    #[must_use]
    pub fn is_active(&self) -> bool {
        self.points.iter().any(ContactPoint::is_active)
    }

    /// Get the number of contact points.
    #[must_use]
    pub fn len(&self) -> usize {
        self.points.len()
    }

    /// Check if the manifold is empty.
    #[must_use]
    pub fn is_empty(&self) -> bool {
        self.points.is_empty()
    }

    /// Iterate over contact points.
    pub fn iter(&self) -> impl Iterator<Item = &ContactPoint> {
        self.points.iter()
    }

    /// Remove contacts that are no longer active (separation > threshold).
    pub fn prune(&mut self, separation_threshold: f64) {
        self.points
            .retain(|p| p.penetration > -separation_threshold);
        self.update_average_normal();
    }

    /// Limit the manifold to at most N points, keeping the deepest.
    pub fn limit(&mut self, max_points: usize) {
        if self.points.len() <= max_points {
            return;
        }

        // Sort by penetration depth (deepest first)
        self.points.sort_by(|a, b| {
            b.penetration
                .partial_cmp(&a.penetration)
                .unwrap_or(std::cmp::Ordering::Equal)
        });

        self.points.truncate(max_points);
        self.update_average_normal();
    }
}

/// The force resulting from a contact.
///
/// Contact forces are decomposed into normal (perpendicular to surface)
/// and friction (tangential to surface) components.
#[derive(Debug, Clone, Copy, PartialEq, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ContactForce {
    /// Normal force vector (perpendicular to contact surface).
    ///
    /// Points from body B toward body A (same direction as contact normal).
    /// Magnitude is always non-negative (contacts can only push, not pull).
    pub normal: Vector3<f64>,

    /// Friction force vector (tangential to contact surface).
    ///
    /// Opposes relative sliding motion between the bodies.
    /// Magnitude is bounded by μ * |F_normal| (friction cone).
    pub friction: Vector3<f64>,

    /// The contact point this force applies to.
    pub position: Point3<f64>,
}

impl ContactForce {
    /// Create a zero contact force.
    #[must_use]
    pub fn zero() -> Self {
        Self::default()
    }

    /// Create a contact force with only normal component.
    #[must_use]
    pub fn normal_only(normal: Vector3<f64>, position: Point3<f64>) -> Self {
        Self {
            normal,
            friction: Vector3::zeros(),
            position,
        }
    }

    /// Create a contact force with both components.
    #[must_use]
    pub fn new(normal: Vector3<f64>, friction: Vector3<f64>, position: Point3<f64>) -> Self {
        Self {
            normal,
            friction,
            position,
        }
    }

    /// Get the total force (normal + friction).
    #[must_use]
    pub fn total(&self) -> Vector3<f64> {
        self.normal + self.friction
    }

    /// Get the magnitude of the normal force.
    #[must_use]
    pub fn normal_magnitude(&self) -> f64 {
        self.normal.norm()
    }

    /// Get the magnitude of the friction force.
    #[must_use]
    pub fn friction_magnitude(&self) -> f64 {
        self.friction.norm()
    }

    /// Compute the torque about a point (e.g., center of mass).
    #[must_use]
    pub fn torque_about(&self, point: &Point3<f64>) -> Vector3<f64> {
        let r = self.position - point;
        r.cross(&self.total())
    }

    /// Check if the force is effectively zero.
    #[must_use]
    pub fn is_zero(&self, epsilon: f64) -> bool {
        self.normal.norm_squared() < epsilon * epsilon
            && self.friction.norm_squared() < epsilon * epsilon
    }

    /// Scale the force by a factor.
    #[must_use]
    pub fn scale(&self, factor: f64) -> Self {
        Self {
            normal: self.normal * factor,
            friction: self.friction * factor,
            position: self.position,
        }
    }

    /// Add another contact force (assumes same position).
    #[must_use]
    pub fn add(&self, other: &Self) -> Self {
        Self {
            normal: self.normal + other.normal,
            friction: self.friction + other.friction,
            position: self.position, // Keep original position
        }
    }
}

/// Find the closest points between two line segments.
///
/// Returns the closest point on segment A and the closest point on segment B.
#[allow(
    clippy::many_single_char_names,          // a,b,e,f,s,t are standard math notation
    clippy::suspicious_operation_groupings   // a*e - b*b is the correct determinant
)]
fn closest_points_segments(
    start_a: Point3<f64>,
    end_a: Point3<f64>,
    start_b: Point3<f64>,
    end_b: Point3<f64>,
) -> (Point3<f64>, Point3<f64>) {
    let d1 = end_a - start_a; // Direction of segment A
    let d2 = end_b - start_b; // Direction of segment B
    let r = start_a - start_b;

    let a = d1.dot(&d1); // Squared length of segment A
    let e = d2.dot(&d2); // Squared length of segment B
    let f = d2.dot(&r);

    // Check for degenerate segments
    let eps = 1e-10;

    if a <= eps && e <= eps {
        // Both segments are points
        return (start_a, start_b);
    }

    let (s, t) = if a <= eps {
        // Segment A is a point
        let t = (f / e).clamp(0.0, 1.0);
        (0.0, t)
    } else if e <= eps {
        // Segment B is a point
        let s = ((-d1.dot(&r)) / a).clamp(0.0, 1.0);
        (s, 0.0)
    } else {
        // General case
        let b = d1.dot(&d2);
        let c = d1.dot(&r);
        let denom = a * e - b * b;

        // If segments are parallel, pick arbitrary s
        let mut s = if denom.abs() > eps {
            ((b * f - c * e) / denom).clamp(0.0, 1.0)
        } else {
            0.0
        };

        // Compute t for closest point on segment B
        let mut t = (b * s + f) / e;

        // Clamp t and recompute s if needed
        if t < 0.0 {
            t = 0.0;
            s = (-c / a).clamp(0.0, 1.0);
        } else if t > 1.0 {
            t = 1.0;
            s = ((b - c) / a).clamp(0.0, 1.0);
        }

        (s, t)
    };

    let closest_a = start_a + d1 * s;
    let closest_b = start_b + d2 * t;

    (closest_a, closest_b)
}

#[cfg(test)]
#[allow(
    clippy::unwrap_used,
    clippy::expect_used,
    clippy::float_cmp,
    clippy::similar_names
)]
mod tests {
    use super::*;
    use approx::assert_relative_eq;

    #[test]
    fn test_contact_point_sphere_plane() {
        // Sphere at height 0.9 with radius 1.0, plane at z=0
        let contact = ContactPoint::sphere_plane(
            Point3::new(0.0, 0.0, 0.9),
            1.0,
            Vector3::new(0.0, 0.0, 1.0),
            0.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        assert_relative_eq!(contact.penetration, 0.1, epsilon = 1e-10);
        assert_relative_eq!(contact.normal.z, 1.0, epsilon = 1e-10);
    }

    #[test]
    fn test_contact_point_sphere_plane_no_contact() {
        // Sphere at height 2.0 with radius 1.0, plane at z=0
        let contact = ContactPoint::sphere_plane(
            Point3::new(0.0, 0.0, 2.0),
            1.0,
            Vector3::new(0.0, 0.0, 1.0),
            0.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        assert!(contact.is_none());
    }

    #[test]
    fn test_contact_point_sphere_sphere() {
        // Two spheres with radius 1.0, centers 1.5 apart
        let contact = ContactPoint::sphere_sphere(
            Point3::new(0.0, 0.0, 0.0),
            1.0,
            Point3::new(1.5, 0.0, 0.0),
            1.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        assert_relative_eq!(contact.penetration, 0.5, epsilon = 1e-10);
        assert_relative_eq!(contact.normal.x, -1.0, epsilon = 1e-10);
    }

    #[test]
    fn test_velocity_decomposition() {
        let contact = ContactPoint {
            position: Point3::origin(),
            normal: Vector3::new(0.0, 0.0, 1.0),
            penetration: 0.01,
            body_a: BodyId::new(0),
            body_b: BodyId::new(1),
        };

        let velocity = Vector3::new(1.0, 2.0, 3.0);
        let (v_n, v_t) = contact.decompose_velocity(&velocity);

        assert_relative_eq!(v_n, 3.0, epsilon = 1e-10);
        assert_relative_eq!(v_t.x, 1.0, epsilon = 1e-10);
        assert_relative_eq!(v_t.y, 2.0, epsilon = 1e-10);
        assert_relative_eq!(v_t.z, 0.0, epsilon = 1e-10);
    }

    #[test]
    fn test_contact_manifold() {
        let p1 = ContactPoint {
            position: Point3::new(-1.0, 0.0, 0.0),
            normal: Vector3::new(0.0, 0.0, 1.0),
            penetration: 0.01,
            body_a: BodyId::new(0),
            body_b: BodyId::new(1),
        };

        let p2 = ContactPoint {
            position: Point3::new(1.0, 0.0, 0.0),
            normal: Vector3::new(0.0, 0.0, 1.0),
            penetration: 0.02,
            body_a: BodyId::new(0),
            body_b: BodyId::new(1),
        };

        let manifold = ContactManifold::from_points(vec![p1, p2]).unwrap();

        assert_eq!(manifold.len(), 2);
        assert_relative_eq!(manifold.max_penetration(), 0.02, epsilon = 1e-10);

        let centroid = manifold.centroid().unwrap();
        assert_relative_eq!(centroid.x, 0.0, epsilon = 1e-10);
    }

    #[test]
    fn test_contact_force_torque() {
        let force = ContactForce {
            normal: Vector3::new(0.0, 0.0, 100.0),
            friction: Vector3::new(-10.0, 0.0, 0.0),
            position: Point3::new(1.0, 0.0, 0.0),
        };

        // Torque about origin: r × F = (1,0,0) × (-10, 0, 100)
        let torque = force.torque_about(&Point3::origin());

        // (1,0,0) × (-10,0,100) = (0*100 - 0*0, 0*(-10) - 1*100, 1*0 - 0*(-10))
        //                       = (0, -100, 0)
        assert_relative_eq!(torque.y, -100.0, epsilon = 1e-10);
    }

    // =========================================================================
    // Box collision tests
    // =========================================================================

    #[test]
    fn test_box_sphere_contact() {
        // Box centered at origin with half-extents (1, 1, 1)
        // Sphere at (1.5, 0, 0) with radius 1.0 => penetrating 0.5
        let contact = ContactPoint::box_sphere(
            Point3::origin(),
            Vector3::new(1.0, 1.0, 1.0),
            Point3::new(1.5, 0.0, 0.0),
            1.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        assert_relative_eq!(contact.penetration, 0.5, epsilon = 1e-10);
        // Normal should point from box toward sphere (positive X)
        assert_relative_eq!(contact.normal.x, 1.0, epsilon = 1e-10);
    }

    #[test]
    fn test_box_sphere_contact_corner() {
        // Sphere near corner of box
        let contact = ContactPoint::box_sphere(
            Point3::origin(),
            Vector3::new(1.0, 1.0, 1.0),
            Point3::new(1.5, 1.5, 0.0),
            1.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        assert!(contact.penetration > 0.0);
        // Normal should point roughly toward sphere
        assert!(contact.normal.x > 0.0);
        assert!(contact.normal.y > 0.0);
    }

    #[test]
    fn test_box_sphere_no_contact() {
        // Sphere far from box
        let contact = ContactPoint::box_sphere(
            Point3::origin(),
            Vector3::new(1.0, 1.0, 1.0),
            Point3::new(5.0, 0.0, 0.0),
            1.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        assert!(contact.is_none());
    }

    #[test]
    fn test_box_sphere_inside() {
        // Sphere center inside the box
        let contact = ContactPoint::box_sphere(
            Point3::origin(),
            Vector3::new(2.0, 2.0, 2.0),
            Point3::new(0.5, 0.0, 0.0),
            0.5,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        // Penetration = distance_to_face + radius
        assert!(contact.penetration > 0.0);
    }

    #[test]
    fn test_box_plane_contact() {
        // Box at z=0.5 with half-extent 1.0, plane at z=0
        // Deepest corner is at z=-0.5, penetrating by 0.5
        let contact = ContactPoint::box_plane(
            Point3::new(0.0, 0.0, 0.5),
            Vector3::new(1.0, 1.0, 1.0),
            Vector3::new(0.0, 0.0, 1.0),
            0.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        assert_relative_eq!(contact.penetration, 0.5, epsilon = 1e-10);
        assert_relative_eq!(contact.normal.z, 1.0, epsilon = 1e-10);
    }

    #[test]
    fn test_box_plane_no_contact() {
        // Box above plane
        let contact = ContactPoint::box_plane(
            Point3::new(0.0, 0.0, 2.0),
            Vector3::new(1.0, 1.0, 1.0),
            Vector3::new(0.0, 0.0, 1.0),
            0.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        assert!(contact.is_none());
    }

    #[test]
    fn test_box_plane_manifold() {
        // Box with 4 corners penetrating
        let contacts = ContactPoint::box_plane_manifold(
            Point3::new(0.0, 0.0, 0.5),
            Vector3::new(1.0, 1.0, 1.0),
            Vector3::new(0.0, 0.0, 1.0),
            0.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        // 4 bottom corners should be penetrating
        assert_eq!(contacts.len(), 4);
        for contact in &contacts {
            assert!(contact.penetration > 0.0);
        }
    }

    #[test]
    fn test_box_box_contact() {
        // Two boxes overlapping on X axis
        let contact = ContactPoint::box_box(
            Point3::new(0.0, 0.0, 0.0),
            Vector3::new(1.0, 1.0, 1.0),
            Point3::new(1.5, 0.0, 0.0),
            Vector3::new(1.0, 1.0, 1.0),
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        // Overlap = (1+1) - 1.5 = 0.5
        assert_relative_eq!(contact.penetration, 0.5, epsilon = 1e-10);
    }

    #[test]
    fn test_box_box_no_contact() {
        // Two boxes separated
        let contact = ContactPoint::box_box(
            Point3::new(0.0, 0.0, 0.0),
            Vector3::new(1.0, 1.0, 1.0),
            Point3::new(5.0, 0.0, 0.0),
            Vector3::new(1.0, 1.0, 1.0),
            BodyId::new(0),
            BodyId::new(1),
        );

        assert!(contact.is_none());
    }

    // =========================================================================
    // Capsule collision tests
    // =========================================================================

    #[test]
    fn test_capsule_plane_contact() {
        // Capsule from (0,0,0) to (0,0,2) with radius 0.5
        // Plane at z=-0.3 (capsule penetrating by 0.2)
        let contact = ContactPoint::capsule_plane(
            Point3::new(0.0, 0.0, 0.0),
            Point3::new(0.0, 0.0, 2.0),
            0.5,
            Vector3::new(0.0, 0.0, 1.0),
            -0.3,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        // Penetration = radius - distance = 0.5 - 0.3 = 0.2
        assert_relative_eq!(contact.penetration, 0.2, epsilon = 1e-10);
    }

    #[test]
    fn test_capsule_plane_no_contact() {
        // Capsule above plane
        let contact = ContactPoint::capsule_plane(
            Point3::new(0.0, 0.0, 2.0),
            Point3::new(0.0, 0.0, 4.0),
            0.5,
            Vector3::new(0.0, 0.0, 1.0),
            0.0,
            BodyId::new(0),
            BodyId::new(1),
        );

        assert!(contact.is_none());
    }

    #[test]
    fn test_capsule_sphere_contact() {
        // Capsule from (-1,0,0) to (1,0,0) with radius 0.5
        // Sphere at (0,1,0) with radius 0.7 (penetrating)
        let contact = ContactPoint::capsule_sphere(
            Point3::new(-1.0, 0.0, 0.0),
            Point3::new(1.0, 0.0, 0.0),
            0.5,
            Point3::new(0.0, 1.0, 0.0),
            0.7,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        // Combined radius 1.2, distance 1.0 => penetration 0.2
        assert_relative_eq!(contact.penetration, 0.2, epsilon = 1e-10);
    }

    #[test]
    fn test_capsule_sphere_end_contact() {
        // Sphere near end of capsule
        let contact = ContactPoint::capsule_sphere(
            Point3::new(0.0, 0.0, 0.0),
            Point3::new(0.0, 0.0, 2.0),
            0.5,
            Point3::new(0.0, 0.0, 2.5),
            0.3,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        // Distance from end to sphere center = 0.5, combined radius = 0.8
        assert_relative_eq!(contact.penetration, 0.3, epsilon = 1e-10);
    }

    #[test]
    fn test_capsule_capsule_parallel() {
        // Two parallel capsules
        let contact = ContactPoint::capsule_capsule(
            Point3::new(0.0, 0.0, 0.0),
            Point3::new(0.0, 0.0, 2.0),
            0.5,
            Point3::new(0.8, 0.0, 0.0),
            Point3::new(0.8, 0.0, 2.0),
            0.5,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        // Distance = 0.8, combined radius = 1.0 => penetration = 0.2
        assert_relative_eq!(contact.penetration, 0.2, epsilon = 1e-10);
    }

    #[test]
    fn test_capsule_capsule_perpendicular() {
        // Two perpendicular capsules that are close but not intersecting axes
        // Offset slightly in Z so they don't pass through exact same point
        let contact = ContactPoint::capsule_capsule(
            Point3::new(-1.0, 0.0, 0.0),
            Point3::new(1.0, 0.0, 0.0),
            0.3,
            Point3::new(0.0, -1.0, 0.1),
            Point3::new(0.0, 1.0, 0.1),
            0.3,
            BodyId::new(0),
            BodyId::new(1),
        );

        let contact = contact.expect("should have contact");
        // Distance = 0.1, combined radius = 0.6 => penetration = 0.5
        assert_relative_eq!(contact.penetration, 0.5, epsilon = 1e-10);
    }

    #[test]
    fn test_capsule_capsule_no_contact() {
        // Two capsules far apart
        let contact = ContactPoint::capsule_capsule(
            Point3::new(0.0, 0.0, 0.0),
            Point3::new(0.0, 0.0, 2.0),
            0.5,
            Point3::new(5.0, 0.0, 0.0),
            Point3::new(5.0, 0.0, 2.0),
            0.5,
            BodyId::new(0),
            BodyId::new(1),
        );

        assert!(contact.is_none());
    }

    // =========================================================================
    // Helper function tests
    // =========================================================================

    #[test]
    fn test_closest_points_segments_parallel() {
        let (p1, p2) = closest_points_segments(
            Point3::new(0.0, 0.0, 0.0),
            Point3::new(1.0, 0.0, 0.0),
            Point3::new(0.0, 1.0, 0.0),
            Point3::new(1.0, 1.0, 0.0),
        );

        // Parallel segments - closest points should be at same x
        assert_relative_eq!(p1.x, p2.x, epsilon = 1e-10);
        assert_relative_eq!(p1.y, 0.0, epsilon = 1e-10);
        assert_relative_eq!(p2.y, 1.0, epsilon = 1e-10);
    }

    #[test]
    fn test_closest_points_segments_crossing() {
        let (p1, p2) = closest_points_segments(
            Point3::new(-1.0, 0.0, 0.0),
            Point3::new(1.0, 0.0, 0.0),
            Point3::new(0.0, -1.0, 0.0),
            Point3::new(0.0, 1.0, 0.0),
        );

        // Crossing at origin
        assert_relative_eq!(p1.coords.norm(), 0.0, epsilon = 1e-10);
        assert_relative_eq!(p2.coords.norm(), 0.0, epsilon = 1e-10);
    }

    #[test]
    fn test_closest_points_segments_endpoints() {
        let (p1, p2) = closest_points_segments(
            Point3::new(0.0, 0.0, 0.0),
            Point3::new(1.0, 0.0, 0.0),
            Point3::new(2.0, 0.0, 0.0),
            Point3::new(3.0, 0.0, 0.0),
        );

        // Endpoints should be closest
        assert_relative_eq!(p1.x, 1.0, epsilon = 1e-10);
        assert_relative_eq!(p2.x, 2.0, epsilon = 1e-10);
    }
}
