//! §41 AC18 Golden-File Conformance Tests.
//!
//! Compares CortenForge simulation output against MuJoCo-generated .npy golden
//! files for flag-gated behavior. Each test loads the same canonical MJCF model,
//! sets the same flags, steps the same number of times, and compares `qacc`
//! element-wise against the golden data.
//!
//! Golden files are generated by `sim/L0/tests/scripts/gen_flag_golden.py`.
//! See `sim/L0/tests/assets/golden/flags/README.md` for regeneration instructions.

use sim_core::DISABLE_GRAVITY;
use sim_mjcf::load_model;

/// Parse a NumPy .npy v1.0 file into shape + f64 data.
///
/// Supports only v1.0 format, little-endian float64 (`<f8`), C-contiguous.
/// Returns `None` if the file doesn't exist or can't be parsed.
fn parse_npy(path: &std::path::Path) -> Option<(Vec<usize>, Vec<f64>)> {
    let bytes = std::fs::read(path).ok()?;

    // Magic: \x93NUMPY
    if bytes.len() < 10 || &bytes[0..6] != b"\x93NUMPY" {
        panic!("invalid .npy magic");
    }
    let major = bytes[6];
    let minor = bytes[7];
    assert!(major == 1 && minor == 0, "only .npy v1.0 supported");

    let header_len = u16::from_le_bytes([bytes[8], bytes[9]]) as usize;
    let header_end = 10 + header_len;
    let header = std::str::from_utf8(&bytes[10..header_end]).expect("header not utf-8");

    // Parse dtype — must be '<f8' (little-endian float64)
    assert!(
        header.contains("'<f8'") || header.contains("'float64'"),
        "only float64 dtype supported, got: {header}"
    );

    // Parse Fortran order — must be False
    assert!(
        header.contains("'fortran_order': False"),
        "only C-contiguous arrays supported"
    );

    // Parse shape: 'shape': (10, 1) or 'shape': (10,)
    let shape_start = header.find("'shape': (").expect("no shape in header") + 10;
    let shape_end = header[shape_start..].find(')').expect("no shape end") + shape_start;
    let shape_str = &header[shape_start..shape_end];
    let shape: Vec<usize> = shape_str
        .split(',')
        .filter(|s| !s.trim().is_empty())
        .map(|s| s.trim().parse().expect("bad shape dim"))
        .collect();

    // Parse data
    let data_bytes = &bytes[header_end..];
    let n_elements: usize = shape.iter().product();
    assert_eq!(
        data_bytes.len(),
        n_elements * 8,
        "data size mismatch: {} bytes for {} elements",
        data_bytes.len(),
        n_elements
    );

    let data: Vec<f64> = data_bytes
        .chunks_exact(8)
        .map(|chunk| f64::from_le_bytes(chunk.try_into().unwrap()))
        .collect();

    Some((shape, data))
}

/// Path to golden file assets.
fn golden_path(filename: &str) -> std::path::PathBuf {
    let manifest_dir = env!("CARGO_MANIFEST_DIR");
    std::path::Path::new(manifest_dir)
        .join("assets")
        .join("golden")
        .join("flags")
        .join(filename)
}

// ============================================================================
// AC18: DISABLE_GRAVITY golden-file conformance
// ============================================================================

#[test]
fn ac18_golden_disable_gravity() {
    let npy_path = golden_path("disable_gravity_qacc.npy");
    let (golden_shape, golden_data) = match parse_npy(&npy_path) {
        Some(v) => v,
        None => {
            eprintln!(
                "SKIP ac18_golden_disable_gravity: golden file not found at {}",
                npy_path.display()
            );
            eprintln!("  Regenerate with: uv run sim/L0/tests/scripts/gen_flag_golden.py");
            return;
        }
    };

    let nsteps = golden_shape[0];
    let nv_golden = golden_shape[1];
    assert_eq!(nsteps, 10, "golden file should have 10 steps");

    // Load the same canonical model
    let model_path = golden_path("flag_golden_test.xml");
    let xml = std::fs::read_to_string(&model_path).expect("failed to read golden model XML");
    let mut model = load_model(&xml).expect("failed to load golden model");
    assert_eq!(
        model.nv, nv_golden,
        "model nv ({}) != golden nv ({})",
        model.nv, nv_golden
    );

    // Set DISABLE_GRAVITY
    model.disableflags |= DISABLE_GRAVITY;

    let mut data = model.make_data();

    // Step 10 times, comparing qacc at each step
    for step in 0..nsteps {
        data.step(&model).expect("step failed");

        let row_start = step * nv_golden;
        for dof in 0..nv_golden {
            let expected = golden_data[row_start + dof];
            let actual = data.qacc[dof];
            let diff = (actual - expected).abs();
            assert!(
                diff < 1e-8,
                "qacc mismatch at step {step}, dof {dof}: \
                 actual={actual}, expected={expected}, diff={diff}"
            );
        }
    }
}
