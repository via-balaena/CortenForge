//! Label types for dataset annotations.

use serde::{Deserialize, Serialize};

use crate::ValidationError;

/// Source of a detection label (provenance).
///
/// Tracks how a label was created for data quality and filtering.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum LabelSource {
    /// Automatically generated by simulation.
    #[default]
    SimAuto,
    /// Human-annotated.
    Human,
    /// Generated by a model (pseudo-label).
    Model,
}

impl LabelSource {
    /// Returns `true` if this is a ground-truth label (sim or human).
    #[must_use]
    pub const fn is_ground_truth(&self) -> bool {
        matches!(self, Self::SimAuto | Self::Human)
    }

    /// Returns `true` if this is human-annotated.
    #[must_use]
    pub const fn is_human(&self) -> bool {
        matches!(self, Self::Human)
    }

    /// Returns `true` if this is a model-generated pseudo-label.
    #[must_use]
    pub const fn is_model(&self) -> bool {
        matches!(self, Self::Model)
    }
}

/// A class label with ID and name.
#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct ClassLabel {
    /// Numeric class ID.
    pub id: u32,
    /// Human-readable class name.
    pub name: String,
}

impl ClassLabel {
    /// Creates a new class label.
    #[must_use]
    pub fn new(id: u32, name: impl Into<String>) -> Self {
        Self {
            id,
            name: name.into(),
        }
    }
}

/// Ground truth detection label for training.
///
/// Contains 3D world position and 2D bounding box with provenance.
///
/// # Example
///
/// ```
/// use ml_types::{DetectionLabel, LabelSource};
///
/// let label = DetectionLabel {
///     center_world: [1.0, 2.0, 3.0],
///     bbox_px: Some([100.0, 200.0, 150.0, 280.0]),
///     bbox_norm: Some([0.1, 0.2, 0.15, 0.28]),
///     class_id: 0,
///     source: Some(LabelSource::SimAuto),
///     source_confidence: None,
/// };
///
/// assert!(label.validate().is_ok());
/// ```
#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub struct DetectionLabel {
    /// 3D world position of the object center.
    pub center_world: [f32; 3],

    /// Pixel coordinates `[x0, y0, x1, y1]` (optional).
    pub bbox_px: Option<[f32; 4]>,

    /// Normalized coordinates `[x0, y0, x1, y1]` in `[0, 1]` (optional).
    pub bbox_norm: Option<[f32; 4]>,

    /// Class ID.
    pub class_id: u32,

    /// Label source (provenance).
    pub source: Option<LabelSource>,

    /// Confidence if model-generated.
    pub source_confidence: Option<f32>,
}

impl DetectionLabel {
    /// Creates a new detection label.
    #[must_use]
    pub const fn new(center_world: [f32; 3], class_id: u32) -> Self {
        Self {
            center_world,
            bbox_px: None,
            bbox_norm: None,
            class_id,
            source: None,
            source_confidence: None,
        }
    }

    /// Creates a label with normalized bounding box.
    #[must_use]
    pub const fn with_bbox_norm(
        center_world: [f32; 3],
        bbox_norm: [f32; 4],
        class_id: u32,
        source: LabelSource,
    ) -> Self {
        Self {
            center_world,
            bbox_px: None,
            bbox_norm: Some(bbox_norm),
            class_id,
            source: Some(source),
            source_confidence: None,
        }
    }

    /// Validates the label data.
    ///
    /// # Errors
    ///
    /// Returns an error if:
    /// - Pixel bbox has invalid order or negative values
    /// - Normalized bbox is out of range `[0, 1]`
    /// - Source confidence is out of range `[0, 1]`
    pub fn validate(&self) -> Result<(), ValidationError> {
        // Validate pixel bbox
        if let Some(px) = self.bbox_px {
            if px[0].is_nan()
                || px[1].is_nan()
                || px[2].is_nan()
                || px[3].is_nan()
                || px[0] > px[2]
                || px[1] > px[3]
                || px[0] < 0.0
                || px[1] < 0.0
            {
                return Err(ValidationError::InvalidBboxPx(px));
            }
        }

        // Validate normalized bbox
        if let Some(norm) = self.bbox_norm {
            let in_range = norm.iter().all(|v| !v.is_nan() && *v >= 0.0 && *v <= 1.0);
            if !in_range || norm[0] > norm[2] || norm[1] > norm[3] {
                return Err(ValidationError::InvalidBboxNorm(norm));
            }
        }

        // Validate source confidence
        if let Some(conf) = self.source_confidence {
            if conf.is_nan() || !(0.0..=1.0).contains(&conf) {
                return Err(ValidationError::InvalidSourceConfidence(conf));
            }
        }

        Ok(())
    }

    /// Checks if the label has a bounding box (pixel or normalized).
    #[must_use]
    pub const fn has_bbox(&self) -> bool {
        self.bbox_px.is_some() || self.bbox_norm.is_some()
    }

    /// Returns the label source, defaulting to `SimAuto`.
    #[must_use]
    pub fn source_or_default(&self) -> LabelSource {
        self.source.unwrap_or_default()
    }
}

impl Default for DetectionLabel {
    fn default() -> Self {
        Self::new([0.0, 0.0, 0.0], 0)
    }
}

#[cfg(test)]
#[allow(clippy::unwrap_used, clippy::expect_used, clippy::float_cmp)]
mod tests {
    use super::*;

    #[test]
    fn label_source_ground_truth() {
        assert!(LabelSource::SimAuto.is_ground_truth());
        assert!(LabelSource::Human.is_ground_truth());
        assert!(!LabelSource::Model.is_ground_truth());
    }

    #[test]
    fn label_source_types() {
        assert!(LabelSource::Human.is_human());
        assert!(LabelSource::Model.is_model());
        assert!(!LabelSource::SimAuto.is_human());
    }

    #[test]
    fn class_label_new() {
        let label = ClassLabel::new(5, "person");
        assert_eq!(label.id, 5);
        assert_eq!(label.name, "person");
    }

    #[test]
    fn detection_label_new() {
        let label = DetectionLabel::new([1.0, 2.0, 3.0], 0);
        assert_eq!(label.center_world, [1.0, 2.0, 3.0]);
        assert_eq!(label.class_id, 0);
        assert!(label.bbox_norm.is_none());
    }

    #[test]
    fn detection_label_with_bbox() {
        let label = DetectionLabel::with_bbox_norm(
            [1.0, 2.0, 3.0],
            [0.1, 0.2, 0.3, 0.4],
            1,
            LabelSource::Human,
        );

        assert!(label.has_bbox());
        assert_eq!(label.source_or_default(), LabelSource::Human);
    }

    #[test]
    fn detection_label_validate_ok() {
        let label = DetectionLabel::with_bbox_norm(
            [0.0, 0.0, 0.0],
            [0.1, 0.2, 0.5, 0.6],
            0,
            LabelSource::SimAuto,
        );
        assert!(label.validate().is_ok());
    }

    #[test]
    fn detection_label_validate_invalid_bbox_norm() {
        let label = DetectionLabel {
            center_world: [0.0, 0.0, 0.0],
            bbox_px: None,
            bbox_norm: Some([0.5, 0.6, 0.1, 0.2]), // x0 > x1
            class_id: 0,
            source: None,
            source_confidence: None,
        };
        assert!(label.validate().is_err());

        let out_of_range = DetectionLabel {
            center_world: [0.0, 0.0, 0.0],
            bbox_px: None,
            bbox_norm: Some([0.0, 0.0, 1.5, 1.0]), // x1 > 1
            class_id: 0,
            source: None,
            source_confidence: None,
        };
        assert!(out_of_range.validate().is_err());
    }

    #[test]
    fn detection_label_validate_invalid_confidence() {
        let label = DetectionLabel {
            center_world: [0.0, 0.0, 0.0],
            bbox_px: None,
            bbox_norm: None,
            class_id: 0,
            source: Some(LabelSource::Model),
            source_confidence: Some(1.5), // > 1.0
        };
        assert!(label.validate().is_err());
    }

    #[test]
    fn detection_label_serialization() {
        let label = DetectionLabel::with_bbox_norm(
            [1.0, 2.0, 3.0],
            [0.1, 0.2, 0.3, 0.4],
            0,
            LabelSource::SimAuto,
        );

        let json = serde_json::to_string(&label);
        assert!(json.is_ok());

        let parsed: Result<DetectionLabel, _> = serde_json::from_str(&json.unwrap_or_default());
        assert!(parsed.is_ok());
    }
}
